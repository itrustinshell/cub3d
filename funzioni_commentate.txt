void reaching_first_side(char **map_grid, double alpha, t_c3d *c3d, t_ray *ray) //la verisone commentata è nel file versioni commentate
{   
	t_point first_impact_point_with_sx; //calcolo sia il punto con sx che con sy
	t_point first_impact_point_with_sy;

	ray->first_impact_point = chose_side_point(c3d, ray); //individua uno dei vertici interni della cella
   
	calculate_dx_dy(c3d, ray, "dx"); //dx viene calcolato solo qui perchè poi saranno solo incrementi fissi di TILE_SIZE
	calculate_dx_dy(c3d, ray, "dY");  printf("\nla prima cella verso cui il raggio si sta dirigendo è: %d, %d\n", (int)ray->first_impact_point.x / TILE_SIZE,  (int)ray->first_impact_point.y /TILE_SIZE); printf("ray.dx = %f, ray.dy = %f\n", fabs(ray->dx), fabs(ray->dy));  //#NOTA_1
   
	ray->path_x = calculate_sx_sy(c3d->map_fm_file.w, ray->dx, ray->dy, alpha, PATH_X);
	first_impact_point_with_sx = calculation_of_end_point_along_path_x(c3d, ray, ray->path_x, alpha); /*calcolo il punto lungo sx */ printf("primo punto calcolato con path_x: %d, %d\n", (int)first_impact_point_with_sx.x, (int)first_impact_point_with_sx.y);
   
	ray->path_y = calculate_sx_sy(c3d->map_fm_file.w, ray->dx, ray->dy, alpha, PATH_Y); 
	first_impact_point_with_sy = calculation_of_end_point_along_path_y(c3d, ray, ray->path_y, alpha); printf("primo punto calcolato con path_y: %d, %d\n", (int)first_impact_point_with_sy.x, (int)first_impact_point_with_sy.y);

	if (!is_it_inside_map_perimeter(first_impact_point_with_sx, c3d)) //#NOTA_2 
	{
		ray->first_impact_point = first_impact_point_with_sy;
		return;
	}
	if (is_it_a_wall(c3d->map_fm_file.grid, first_impact_point_with_sx, c3d))
		check_if_are_both_walls_and_set_firstImpactPoint(first_impact_point_with_sx, first_impact_point_with_sy, map_grid, ray, c3d);
	else
	{
		if (!is_it_inside_map_perimeter(first_impact_point_with_sy, c3d)) //# NOTA_2
		{
			ray->first_impact_point = first_impact_point_with_sx;
			return;
		}
		if (is_it_a_wall(c3d->map_fm_file.grid, first_impact_point_with_sy, c3d)) //il punto su sx non era di un muro, quindi ha skippato qulla parte...allora vediamo se us sy il punto è di un muro
		{
			printf("Yes! first impact point with sy is a wall\n");
			//qui significa che il punto con sx non appartiene ad un muro, ma quello con sy si! quindi ritorna il punto ottenuto con sx
			ray->first_impact_point =  first_impact_point_with_sy;
		}
		else //per esssere a questo punto significa che nessuno dei precedenti punti appartiene ad un muro quindi riestituisci sempricemente il punto appartemente all'ipotenusa piu corta
		{
			if (fabs(ray->path_x) <= fabs(ray->path_y)) //confronto tra ipotenuse
				ray->first_impact_point = first_impact_point_with_sx;
			else
				ray->first_impact_point = first_impact_point_with_sy;
		}
	}
	printf("punto di impatto: %d, %d\n",(int)ray->first_impact_point.x, (int)ray->first_impact_point.y);
}


	/* # NOTA_1
	I Verify what is the shorter distance (I use fabs to avoid negatives)
	I return the end-point of the shortest distance.
	*/
   //mi serve trovare ogni volta l'ipotenusa perchè graie a quella mi calcolo il cpunto di impatto con cos e sen
   //ora quando effettuo il raggiungimento del primo punto di impatto, per la prima volta viene calcolato sx e dx.
   /*
   successivamente viene scelto il segmento con lunghezza minore e quindi si restituisce la coordinata del punto di impatto.
   Poniamo il caso che il segmento minore fosse stato sx.
   ma poniamo anche il caso che sy (che non viene preso quindi in considerazion eprchè più lungo) impattaca contro un muro.
   Ebbene questa infromazione potrebbe essere persa.
   Infatti a seguire dalla prima individuazione del primo punto di impatto (che qui abbiamo detto essere indiciduadto con sx),
   gli incrementi successivi sono fatti di TILE_SIZE in TILE_SIZE e pertanto si perderebbe che nel primo sy il raggio aveva impattato
   contro il muro.
   Pertanto conviene a prescindere calcolare i due punti di impatto, un con sx e uno con sy, per essere sicuri che nessuno dei due abbia impattato su un muro.
   solo dopo fare la differenza tra i due per verificare qualce effettivamente è il più piccolo (ovvero quale dei due è anche il primo punto di impatto).
   Essendo la prima volta che un punto incontro solo e soltanto due bene precisi assi allora dovrai ritornare il punto piu piccolo se entrambi sono
   punti di impatto su un muro.... appure ritorni solo il punto piu grande se è un punto di impatto su un muro.
   altrimenti ritorni solo il numero piu piccolo (ovvero quando nessuno dei due è un punto di impatto su un muro)
   */

  	/* #NOTA_2
		inizio con il punto calcolato su sx. Farò lo stesso dopo con sy. 
		In pratica voglio sapere se questo punto è già oltre i confini del mio permimetro.
		per perimetro intendiamo proprio l'aria interna, quella che va oltre il punto di impatto interno.
		Per intenderci intorno alla mappa verrà a crearsi un perimetro.
		Ogni cella di questo perimetro è un quadrato.
		prendnendo un punto che viaggia verso NE questo potrebbe incontrare quel quadrato su suo lato sinistro.
		Ecco cosa intendo per perimetro. Quel lato sinistro è il limite.
		Quindi quand'anche un punto cadesse all'interno di una cella del perimetro ma oltrepassasse tale limite interno,
		ebbene sarebbe al di fuori del perimetro cosi come definito.
		Ora proseguento: se una punto cade fuori questo perimetro significa che matematicamente quel punto ha il corrispetticvo 
		sx (o sx) maggiore dell'altro puto calcolato lungo sy (o sx).
		Quindi dovrò restituire matematicamente l'altro punto. E la funzione non prosegue...ecco perchè c'è un return.
		Se poi il punto tornato è lungo (ma non oltre) il confine, oppure è un muro interno, verrà gestito in dda 
		che non passa la plla a increment qualora ppunto appartenesse ad un muro, altrimenti se non fosse un muro,
		passerebbe la palla a incrment che andrebbe a calcolare il punto di impatto per i successivi incrementi.
		*/